# 装饰器使用说明

## 概述

本项目使用了两个核心装饰器来实现用户认证和权限控制：

1. **`@CurrentUser`** - 用户信息提取装饰器
2. **`@Roles`** - 角色权限控制装饰器

## 装饰器详解

### 1. @CurrentUser 装饰器

**作用**: 从请求中提取当前认证用户的信息

**位置**: `src/common/decorators/current-user.decorator.ts`

**使用方式**:
```typescript
// 获取完整用户对象
@Get('profile')
async getProfile(@CurrentUser() user) {
  return user;
}

// 获取特定用户属性
@Get('profile')
async getProfile(@CurrentUser('id') userId: number) {
  return { userId };
}
```

**优势**:
- 替代了传统的 `@Req() req` 方式
- 代码更简洁，类型更安全
- 自动从 JWT 认证中提取用户信息

### 2. @Roles 装饰器

**作用**: 设置方法或类需要的角色权限

**位置**: `src/common/decorators/roles.decorator.ts`

**使用方式**:
```typescript
// 单个角色
@Roles('admin')
async adminOnlyMethod() {}

// 多个角色（满足其一即可）
@Roles('user', 'admin')
async userOrAdminMethod() {}

// 类级别角色控制
@Controller('admin')
@Roles('admin')
export class AdminController {}
```

**配合守卫**: 需要与 `RolesGuard` 配合使用

## 实际应用示例

### Auth 模块
```typescript
@Controller('auth')
export class AuthController {
  @Get('profile')
  @UseGuards(JwtAuthGuard)
  async getProfile(@CurrentUser() user) {
    return { data: user, message: '获取用户信息成功' };
  }

  @Get('admin/profile')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles('admin')
  async getAdminProfile(@CurrentUser() user) {
    return { data: user, message: '获取管理员信息成功' };
  }
}
```

### Apps 模块
```typescript
@Controller('apps')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AppsController {
  @Post()
  @Roles('user', 'admin')
  async createApp(@Body() dto, @CurrentUser() user) {
    // 使用 @CurrentUser 获取用户信息
    return this.appsService.createApp(dto, user);
  }
}
```

### Chat 模块
```typescript
@Controller('chat')
@UseGuards(JwtAuthGuard, RolesGuard)
export class ChatController {
  @Get('history/:appId')
  @Roles('user', 'admin')
  async getChatHistory(@Param('appId') appId, @CurrentUser() user) {
    // 结合用户权限和当前用户信息
    return this.chatService.getChatHistoryByAppId(appId, limit, user);
  }
}
```

### AI 模块
```typescript
@Controller('ai')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AiController {
  @Post('generate/html')
  @Roles('user', 'admin')
  async generateHtmlCode(@Body('message') message, @CurrentUser() user) {
    const result = await this.aiService.generateHtmlCode(message);
    return {
      ...result,
      generatedBy: user.id,  // 记录生成者
      timestamp: new Date().toISOString(),
    };
  }
}
```

## 权限控制策略

### 角色定义
- **`admin`**: 管理员，拥有所有权限
- **`user`**: 普通用户，拥有基本功能权限

### 权限矩阵
| 功能 | admin | user | 说明 |
|------|-------|------|------|
| 用户管理 | ✅ | ❌ | 创建、更新、删除用户 |
| 应用管理 | ✅ | ✅ | 创建、更新、删除自己的应用 |
| 聊天记录 | ✅ | ✅ | 查看自己的聊天记录 |
| AI代码生成 | ✅ | ✅ | 使用AI服务 |
| 系统统计 | ✅ | ❌ | 查看系统使用统计 |

## 最佳实践

1. **始终使用 `@CurrentUser()` 替代 `@Req()`**
   ```typescript
   // ❌ 不推荐
   async method(@Req() req) {
     const user = req.user;
   }
   
   // ✅ 推荐
   async method(@CurrentUser() user) {
     // 直接使用 user
   }
   ```

2. **合理设置角色权限**
   ```typescript
   // 公开接口
   @Get('public')
   async publicMethod() {}
   
   // 需要登录
   @Get('private')
   @UseGuards(JwtAuthGuard)
   async privateMethod(@CurrentUser() user) {
     // 直接使用 user
   }
   
   // 需要特定角色
   @Get('admin')
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles('admin')
   async adminMethod() {}
   ```

3. **组合使用装饰器**
   ```typescript
   @Post('create')
   @UseGuards(JwtAuthGuard, RolesGuard)
   @Roles('user', 'admin')
   async create(@Body() dto, @CurrentUser() user) {
     // 结合权限控制和用户信息
   }
   ```

## 注意事项

1. **守卫顺序**: 先使用 `JwtAuthGuard`，再使用 `RolesGuard`
2. **角色检查**: `RolesGuard` 会自动检查用户是否具有所需角色
3. **用户信息**: `@CurrentUser()` 装饰器依赖 JWT 认证，确保在需要用户信息的接口上使用 `JwtAuthGuard`
4. **错误处理**: 权限不足时会自动返回 403 错误

## 扩展建议

1. **添加更多角色**: 如 `moderator`、`premium_user` 等
2. **细粒度权限**: 基于资源所有权的权限控制
3. **动态权限**: 根据用户状态动态调整权限
4. **权限日志**: 记录权限检查的日志信息
