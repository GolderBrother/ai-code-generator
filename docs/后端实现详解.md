# AI 零代码应用生成平台 - 后端实现详解

> 本文档详细解释后端架构、API 设计、数据流程和关键技术实现。

## 📋 目录

1. [后端整体架构](#1-后端整体架构)
2. [核心业务流程](#2-核心业务流程)
3. [API 接口设计](#3-api-接口设计)
4. [AI 代码生成实现](#4-ai-代码生成实现)
5. [数据存储设计](#5-数据存储设计)
6. [安全与限流机制](#6-安全与限流机制)
7. [流式响应实现](#7-流式响应实现)
8. [部署与运维](#8-部署与运维)
9. [前端调用示例](#9-前端调用示例)
10. [常见问题解答](#10-常见问题解答)

## 1. 后端整体架构

### 1.1 技术栈概览

```
后端技术栈
├── 核心框架: Spring Boot 3.5.4 + Java 21
├── AI 框架: LangChain4j 1.1.0 + LangGraph4j 1.6.0
├── 数据库: MySQL + MyBatis-Flex
├── 缓存: Redis + Caffeine
├── 消息: Reactor (响应式编程)
├── 安全: Spring Session + Redisson
└── 监控: Spring Boot Actuator + Prometheus
```

### 1.2 分层架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                   表现层 (Controller)                        │
│  • 接收 HTTP 请求                                          │
│  • 参数校验和权限控制                                      │
│  • 调用业务服务                                            │
│  • 返回响应结果                                            │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (Service)                         │
│  • 业务逻辑处理                                            │
│  • 事务管理                                                │
│  • 调用 AI 服务                                            │
│  • 数据持久化                                              │
├─────────────────────────────────────────────────────────────┤
│                    AI 服务层 (AI Service)                   │
│  • LangChain4j 集成                                        │
│  • AI 模型调用                                             │
│  • 工具调用管理                                            │
│  • 对话记忆管理                                            │
├─────────────────────────────────────────────────────────────┤
│                  工作流层 (LangGraph4j)                     │
│  • 复杂 AI 工作流编排                                       │
│  • 节点执行管理                                            │
│  • 状态流转控制                                            │
├─────────────────────────────────────────────────────────────┤
│                    数据层 (Mapper)                          │
│  • 数据库操作                                              │
│  • SQL 执行                                                │
│  • 结果映射                                                │
├─────────────────────────────────────────────────────────────┤
│                    基础设施层                               │
│  • Redis 缓存                                              │
│  • 文件系统                                                │
│  • 外部服务集成                                            │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 核心包结构

```
src/main/java/com/yupi/yuaicodemother/
├── controller/           # 控制器层 - 处理 HTTP 请求
├── service/             # 业务服务层 - 业务逻辑处理
├── ai/                  # AI 服务层 - AI 代码生成核心
├── core/                # 核心业务层 - 代码生成门面
├── langgraph4j/         # 工作流引擎 - 复杂 AI 工作流
├── mapper/              # 数据访问层 - 数据库操作
├── model/               # 数据模型 - DTO、Entity、VO
├── config/              # 配置类 - 各种配置
├── exception/           # 异常处理 - 统一异常管理
├── ratelimter/          # 限流机制 - 分布式限流
├── monitor/             # 监控系统 - AI 服务监控
└── utils/               # 工具类 - 通用工具方法
```

## 2. 核心业务流程

### 2.1 AI 代码生成流程

```
用户请求 → 权限验证 → AI 服务调用 → 代码生成 → 代码解析 → 文件保存 → 流式返回
    ↓           ↓           ↓           ↓         ↓         ↓         ↓
  参数校验   用户身份    模型选择    提示词    结果处理   语法检查   本地存储   实时响应
```

### 2.2 应用创建流程

```
用户输入 → 智能路由 → 类型选择 → 应用创建 → 数据库存储 → 返回应用ID
    ↓         ↓         ↓         ↓         ↓         ↓
  初始化提示词  AI分析   代码类型   构造对象   插入数据   创建成功
```

### 2.3 应用部署流程

```
部署请求 → 权限验证 → 代码检查 → 文件打包 → 上传云端 → 生成链接 → 截图生成
    ↓         ↓         ↓         ↓         ↓         ↓         ↓
  应用ID    用户身份   代码存在    ZIP压缩   对象存储   访问URL   封面图片
```

## 3. API 接口设计

### 3.1 接口规范

**基础响应格式**:
```json
{
  "code": 0,           // 状态码：0-成功，其他-失败
  "data": {},          // 响应数据
  "message": "ok",     // 响应消息
  "description": ""    // 详细描述
}
```

**分页响应格式**:
```json
{
  "code": 0,
  "data": {
    "records": [],     // 数据列表
    "total": 100,      // 总记录数
    "size": 10,        // 每页大小
    "current": 1       // 当前页码
  },
  "message": "ok"
}
```

### 3.2 核心接口列表

#### 3.2.1 应用管理接口

**创建应用**
```http
POST /api/app/add
Content-Type: application/json

{
  "appName": "我的应用",
  "appDesc": "应用描述",
  "appIcon": "图标URL",
  "appType": 0,
  "initPrompt": "创建一个待办事项应用"
}
```

**应用列表查询**
```http
POST /api/app/my/list/page/vo
Content-Type: application/json

{
  "current": 1,
  "pageSize": 10,
  "appName": "搜索关键词",
  "appType": 0
}
```

**应用详情查询**
```http
GET /api/app/get/vo?id={appId}
```

#### 3.2.2 AI 对话接口

**AI 代码生成（流式）**
```http
GET /api/app/chat/gen/code?appId={appId}&message={用户提示词}
Accept: text/event-stream
```

**响应格式（SSE）**:
```
data: {"d":"生成的代码片段1"}
data: {"d":"生成的代码片段2"}
data: {"d":"生成的代码片段3"}
event: done
data: 
```

#### 3.2.3 应用部署接口

**部署应用**
```http
POST /api/app/deploy
Content-Type: application/json

{
  "appId": 123
}
```

**下载代码**
```http
GET /api/app/download/{appId}
```

### 3.3 接口权限控制

**权限注解使用**:
```java
@AuthCheck(mustRole = "admin")  // 需要管理员权限
@RateLimit(limitType = RateLimitType.USER, rate = 5, rateInterval = 60)  // 限流控制
```

**权限级别**:
- `@AuthCheck()`: 需要登录
- `@AuthCheck(mustRole = "admin")`: 需要管理员权限
- `@RateLimit`: 接口限流保护

## 4. AI 代码生成实现

### 4.1 LangChain4j 集成架构

**AI 服务工厂模式**:
```java
@Service
public class AiCodeGeneratorServiceFactory {
    
    // 缓存 AI 服务实例，避免重复创建
    private final Cache<String, AiCodeGeneratorService> serviceCache = Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(Duration.ofMinutes(30))
            .build();
    
    public AiCodeGeneratorService getAiCodeGeneratorService(long appId, CodeGenTypeEnum codeGenType) {
        String cacheKey = buildCacheKey(appId, codeGenType);
        return serviceCache.get(cacheKey, key -> createAiCodeGeneratorService(appId, codeGenType));
    }
}
```

**AI 服务创建**:
```java
private AiCodeGeneratorService createAiCodeGeneratorService(long appId, CodeGenTypeEnum codeGenType) {
    // 1. 构建对话记忆
    MessageWindowChatMemory chatMemory = MessageWindowChatMemory
            .builder()
            .id(appId)
            .chatMemoryStore(redisChatMemoryStore)
            .maxMessages(20)
            .build();
    
    // 2. 加载历史对话
    chatHistoryService.loadChatHistoryToMemory(appId, chatMemory, 20);
    
    // 3. 根据类型创建不同服务
    return switch (codeGenType) {
        case VUE_PROJECT -> createVueProjectService(chatMemory);
        case HTML, MULTI_FILE -> createBasicService(chatMemory);
        default -> throw new BusinessException("不支持的代码生成类型");
    };
}
```

### 4.2 代码生成类型

**HTML 代码生成**:
```java
@SystemMessage(fromResource = "prompt/codegen-html-system-prompt.txt")
HtmlCodeResult generateHtmlCode(String userMessage);

@SystemMessage(fromResource = "prompt/codegen-html-system-prompt.txt")
Flux<String> generateHtmlCodeStream(String userMessage);
```

**多文件项目生成**:
```java
@SystemMessage(fromResource = "prompt/codegen-multi-file-system-prompt.txt")
MultiFileCodeResult generateMultiFileCode(String userMessage);
```

**Vue 项目生成**:
```java
@SystemMessage(fromResource = "prompt/codegen-vue-project-system-prompt.txt")
TokenStream generateVueProjectCodeStream(@MemoryId long appId, @UserMessage String userMessage);
```

### 4.3 工具调用机制

**工具管理器**:
```java
@Component
public class ToolManager {
    
    @Resource
    private List<BaseTool> tools;
    
    public List<Tool> getAllTools() {
        return tools.stream()
                .map(BaseTool::getTool)
                .collect(Collectors.toList());
    }
}
```

**可用工具列表**:
- `FileDeleteTool`: 文件删除工具
- `FileWriteTool`: 文件写入工具
- `ImageSearchTool`: 图片搜索工具
- `LogoGeneratorTool`: Logo 生成工具
- `MermaidDiagramTool`: 图表生成工具

## 5. 数据存储设计

### 5.1 数据库表结构

**用户表 (user)**:
```sql
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `userName` varchar(256) DEFAULT NULL COMMENT '用户昵称',
  `userAccount` varchar(256) NOT NULL COMMENT '账号',
  `userAvatar` varchar(1024) DEFAULT NULL COMMENT '用户头像',
  `userRole` varchar(256) DEFAULT 'user' COMMENT '用户角色：user / admin',
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uni_userAccount` (`userAccount`)
) COMMENT='用户';
```

**应用表 (app)**:
```sql
CREATE TABLE `app` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `appName` varchar(128) NOT NULL COMMENT '应用名称',
  `appDesc` varchar(1024) DEFAULT NULL COMMENT '应用描述',
  `appIcon` varchar(1024) DEFAULT NULL COMMENT '应用图标',
  `appType` int NOT NULL DEFAULT '0' COMMENT '应用类型（0-个人，1-官方）',
  `appStatus` int NOT NULL DEFAULT '0' COMMENT '应用状态（0-待审核，1-通过，2-拒绝）',
  `appVersion` varchar(128) DEFAULT '1.0.0' COMMENT '应用版本',
  `appSize` bigint DEFAULT '0' COMMENT '应用大小（字节）',
  `userId` bigint NOT NULL COMMENT '创建用户 id',
  `codeGenType` varchar(128) NOT NULL COMMENT '代码生成类型',
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_userId` (`userId`)
) COMMENT='应用';
```

**聊天历史表 (chat_history)**:
```sql
CREATE TABLE `chat_history` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `appId` bigint NOT NULL COMMENT '应用 id',
  `userId` bigint NOT NULL COMMENT '用户 id',
  `messageType` int NOT NULL COMMENT '消息类型（0-用户，1-AI）',
  `messageContent` text COMMENT '消息内容',
  `createTime` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updateTime` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `isDelete` tinyint DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`),
  KEY `idx_appId` (`appId`),
  KEY `idx_userId` (`userId`)
) COMMENT='聊天记录';
```

### 5.2 缓存策略

**多级缓存设计**:
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(1000)           // 最大缓存条目数
                .expireAfterWrite(10, TimeUnit.MINUTES)  // 写入后过期时间
                .recordStats());             // 记录统计信息
        return cacheManager;
    }
}
```

**缓存使用示例**:
```java
@Service
public class AppServiceImpl implements AppService {
    
    @Cacheable(value = "app", key = "#appId")
    public App getAppById(Long appId) {
        return appMapper.selectOneById(appId);
    }
    
    @CacheEvict(value = "app", key = "#app.id")
    public boolean updateApp(App app) {
        return appMapper.updateById(app) > 0;
    }
}
```

## 6. 安全与限流机制

### 6.1 身份认证

**Session 管理**:
```yaml
spring:
  session:
    store-type: redis
    timeout: 2592000  # 30天过期
```

**用户登录验证**:
```java
@Component
public class AuthInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 检查是否需要权限验证
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            AuthCheck authCheck = handlerMethod.getMethodAnnotation(AuthCheck.class);
            if (authCheck != null) {
                return checkAuth(request, authCheck);
            }
        }
        return true;
    }
}
```

### 6.2 分布式限流

**Redisson 限流配置**:
```java
@Configuration
public class RedissonConfig {
    
    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
                .setAddress("redis://localhost:6379")
                .setDatabase(0);
        return Redisson.create(config);
    }
}
```

**限流注解使用**:
```java
@RateLimit(limitType = RateLimitType.USER, rate = 5, rateInterval = 60, 
           message = "AI 对话请求过于频繁，请稍后再试")
public Flux<ServerSentEvent<String>> chatToGenCode(...) {
    // 方法实现
}
```

**限流类型**:
- `RateLimitType.USER`: 按用户限流
- `RateLimitType.IP`: 按 IP 限流
- `RateLimitType.GLOBAL`: 全局限流

### 6.3 输入安全

**提示词安全检查**:
```java
@Component
public class PromptSafetyInputGuardrail implements InputGuardrail {
    
    @Override
    public void validate(String input) {
        // 检查是否包含恶意内容
        if (containsMaliciousContent(input)) {
            throw new InputGuardrailException("输入内容包含不当信息");
        }
    }
}
```

## 7. 流式响应实现

### 7.1 SSE 流式响应

**控制器实现**:
```java
@GetMapping(value = "/chat/gen/code", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
@RateLimit(limitType = RateLimitType.USER, rate = 5, rateInterval = 60)
public Flux<ServerSentEvent<String>> chatToGenCode(@RequestParam Long appId,
                                                   @RequestParam String message,
                                                   HttpServletRequest request) {
    // 1. 参数校验
    ThrowUtils.throwIf(appId == null || appId <= 0, ErrorCode.PARAMS_ERROR, "应用 id 错误");
    ThrowUtils.throwIf(StrUtil.isBlank(message), ErrorCode.PARAMS_ERROR, "提示词不能为空");
    
    // 2. 获取当前登录用户
    User loginUser = userService.getLoginUser(request);
    
    // 3. 调用服务生成代码（SSE 流式返回）
    Flux<String> contentFlux = appService.chatToGenCode(appId, message, loginUser);
    
    // 4. 转换为 SSE 格式
    return contentFlux
            .map(chunk -> {
                Map<String, String> wrapper = Map.of("d", chunk);
                String jsonData = JSONUtil.toJsonStr(wrapper);
                return ServerSentEvent.<String>builder()
                        .data(jsonData)
                        .build();
            })
            .concatWith(Mono.just(
                // 发送结束事件
                ServerSentEvent.<String>builder()
                        .event("done")
                        .data("")
                        .build()
            ));
}
```

### 7.2 流式处理流程

**流式代码生成**:
```java
@Override
public Flux<String> chatToGenCode(Long appId, String message, User loginUser) {
    // 1. 参数校验和权限验证
    // 2. 保存用户消息到数据库
    // 3. 设置监控上下文
    // 4. 调用 AI 生成代码（流式）
    Flux<String> codeStream = aiCodeGeneratorFacade.generateAndSaveCodeStream(message, codeGenTypeEnum, appId);
    
    // 5. 处理流式响应
    return streamHandlerExecutor.doExecute(codeStream, chatHistoryService, appId, loginUser, codeGenTypeEnum)
            .doFinally(signalType -> {
                // 流结束时清理监控上下文
                MonitorContextHolder.clearContext();
            });
}
```

**流式处理器**:
```java
@Component
public class StreamHandlerExecutor {
    
    public Flux<String> doExecute(Flux<String> codeStream, 
                                 ChatHistoryService chatHistoryService,
                                 Long appId, User loginUser, CodeGenTypeEnum codeGenTypeEnum) {
        return codeStream
                .doOnNext(chunk -> {
                    // 实时处理每个代码片段
                    log.debug("收到代码片段: {}", chunk);
                })
                .doOnComplete(() -> {
                    // 流式响应完成，保存 AI 回复到数据库
                    chatHistoryService.addChatMessage(appId, 
                        "代码生成完成", 
                        ChatHistoryMessageTypeEnum.AI.getValue(), 
                        loginUser.getId());
                });
    }
}
```

## 8. 部署与运维

### 8.1 应用部署流程

**部署服务实现**:
```java
@Override
public String deployApp(Long appId, User loginUser) {
    // 1. 参数校验
    ThrowUtils.throwIf(appId == null || appId <= 0, ErrorCode.PARAMS_ERROR, "应用 ID 错误");
    
    // 2. 查询应用信息
    App app = this.getById(appId);
    ThrowUtils.throwIf(app == null, ErrorCode.NOT_FOUND_ERROR, "应用不存在");
    
    // 3. 权限校验
    if (!app.getUserId().equals(loginUser.getId())) {
        throw new BusinessException(ErrorCode.NO_AUTH_ERROR, "无权限部署该应用");
    }
    
    // 4. 检查代码是否存在
    String codeGenType = app.getCodeGenType();
    String sourceDirName = codeGenType + "_" + appId;
    String sourceDirPath = AppConstant.CODE_OUTPUT_ROOT_DIR + File.separator + sourceDirName;
    
    File sourceDir = new File(sourceDirPath);
    ThrowUtils.throwIf(!sourceDir.exists() || !sourceDir.isDirectory(),
            ErrorCode.NOT_FOUND_ERROR, "应用代码不存在，请先生成代码");
    
    // 5. 部署到云端
    String deployUrl = deployToCloud(sourceDirPath, appId);
    
    // 6. 异步生成截图
    screenshotService.generateAppScreenshotAsync(appId, deployUrl);
    
    return deployUrl;
}
```

### 8.2 监控系统

**AI 服务监控**:
```java
@Component
public class AiModelMonitorListener {
    
    @EventListener
    public void handleAiModelCall(AiModelCallEvent event) {
        // 记录 AI 模型调用统计
        String modelName = event.getModelName();
        long responseTime = event.getResponseTime();
        boolean success = event.isSuccess();
        
        // 更新监控指标
        updateMetrics(modelName, responseTime, success);
    }
}
```

**监控指标**:
- AI 模型调用次数
- 响应时间统计
- 成功率统计
- 成本统计

## 9. 前端调用示例

### 9.1 基础 HTTP 请求

**创建应用**:
```javascript
const createApp = async (appData) => {
  try {
    const response = await fetch('/api/app/add', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include', // 包含 cookies
      body: JSON.stringify(appData)
    });
    
    if (!response.ok) {
      throw new Error('创建应用失败');
    }
    
    const result = await response.json();
    if (result.code === 0) {
      return result.data;
    } else {
      throw new Error(result.message);
    }
  } catch (error) {
    console.error('创建应用失败:', error);
    throw error;
  }
};
```

**查询应用列表**:
```javascript
const getAppList = async (params = {}) => {
  try {
    const response = await fetch('/api/app/my/list/page/vo', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      body: JSON.stringify({
        current: 1,
        pageSize: 10,
        ...params
      })
    });
    
    const result = await response.json();
    if (result.code === 0) {
      return result.data;
    } else {
      throw new Error(result.message);
    }
  } catch (error) {
    console.error('获取应用列表失败:', error);
    throw error;
  }
};
```

### 9.2 SSE 流式请求

**AI 代码生成**:
```javascript
const generateCode = async (appId, message, onChunk, onComplete) => {
  try {
    const url = `/api/app/chat/gen/code?appId=${appId}&message=${encodeURIComponent(message)}`;
    const eventSource = new EventSource(url);
    
    let fullResponse = '';
    
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (data.d) {
          fullResponse += data.d;
          onChunk(data.d); // 实时显示代码片段
        }
      } catch (e) {
        console.error('解析响应数据失败:', e);
      }
    };
    
    eventSource.addEventListener('done', () => {
      onComplete(fullResponse); // 代码生成完成
      eventSource.close();
    });
    
    eventSource.onerror = (error) => {
      console.error('SSE 连接错误:', error);
      eventSource.close();
    };
    
  } catch (error) {
    console.error('代码生成失败:', error);
    throw error;
  }
};

// 使用示例
generateCode(
  123, 
  "创建一个待办事项应用",
  (chunk) => {
    // 实时显示代码片段
    console.log('收到代码片段:', chunk);
  },
  (fullCode) => {
    // 代码生成完成
    console.log('完整代码:', fullCode);
  }
);
```

### 9.3 文件下载

**下载应用代码**:
```javascript
const downloadAppCode = async (appId) => {
  try {
    const response = await fetch(`/api/app/download/${appId}`, {
      method: 'GET',
      credentials: 'include',
    });
    
    if (!response.ok) {
      throw new Error('下载失败');
    }
    
    // 获取文件名
    const contentDisposition = response.headers.get('content-disposition');
    const filename = contentDisposition ? 
      contentDisposition.split('filename=')[1]?.replace(/"/g, '') : 
      `app_${appId}.zip`;
    
    // 创建下载链接
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
  } catch (error) {
    console.error('下载代码失败:', error);
    throw error;
  }
};
```

### 9.4 错误处理

**统一错误处理**:
```javascript
class ApiError extends Error {
  constructor(code, message, description = '') {
    super(message);
    this.code = code;
    this.description = description;
  }
}

const handleApiResponse = (response) => {
  if (!response.ok) {
    throw new ApiError(response.status, `HTTP ${response.status}: ${response.statusText}`);
  }
  
  return response.json().then(data => {
    if (data.code === 0) {
      return data.data;
    } else {
      throw new ApiError(data.code, data.message, data.description);
    }
  });
};

// 使用示例
const safeApiCall = async (apiFunction) => {
  try {
    return await apiFunction();
  } catch (error) {
    if (error instanceof ApiError) {
      // 处理业务错误
      console.error(`业务错误 ${error.code}: ${error.message}`);
      // 显示用户友好的错误信息
      showErrorMessage(error.message);
    } else {
      // 处理网络错误
      console.error('网络错误:', error);
      showErrorMessage('网络连接失败，请检查网络设置');
    }
    throw error;
  }
};
```

## 10. 常见问题解答

### 10.1 前端开发者常见问题

**Q: 为什么我的请求总是返回 401 错误？**
A: 这通常是因为用户未登录或 Session 过期。请确保：
1. 用户已经登录
2. 请求包含 `credentials: 'include'`
3. 检查浏览器 Cookie 是否正常

**Q: SSE 连接为什么经常断开？**
A: SSE 连接可能因为以下原因断开：
1. 网络不稳定
2. 服务器超时
3. 浏览器限制
建议实现自动重连机制：

```javascript
const createSSEConnection = (url, options) => {
  let eventSource = null;
  let reconnectAttempts = 0;
  const maxReconnectAttempts = 5;
  
  const connect = () => {
    eventSource = new EventSource(url);
    
    eventSource.onopen = () => {
      console.log('SSE 连接已建立');
      reconnectAttempts = 0;
    };
    
    eventSource.onerror = () => {
      eventSource.close();
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        console.log(`SSE 连接断开，${reconnectAttempts}秒后重连...`);
        setTimeout(connect, reconnectAttempts * 1000);
      }
    };
    
    return eventSource;
  };
  
  return connect();
};
```

**Q: 如何优化大文件的下载体验？**
A: 对于大文件下载，建议：
1. 显示下载进度
2. 支持断点续传
3. 提供取消下载功能

```javascript
const downloadWithProgress = async (url, filename) => {
  const response = await fetch(url, { credentials: 'include' });
  const reader = response.body.getReader();
  const contentLength = +response.headers.get('content-length');
  
  let receivedLength = 0;
  const chunks = [];
  
  while (true) {
    const { done, value } = await reader.read();
    
    if (done) break;
    
    chunks.push(value);
    receivedLength += value.length;
    
    // 更新进度
    const progress = (receivedLength / contentLength) * 100;
    updateProgress(progress);
  }
  
  // 合并数据块并下载
  const blob = new Blob(chunks);
  const downloadUrl = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = downloadUrl;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(downloadUrl);
};
```

### 10.2 性能优化建议

**前端优化**:
1. 使用防抖处理搜索输入
2. 实现虚拟滚动处理长列表
3. 合理使用缓存减少重复请求
4. 图片懒加载和压缩

**后端优化**:
1. 数据库查询优化和索引
2. Redis 缓存热点数据
3. 异步处理耗时操作
4. 合理的限流策略

### 10.3 调试技巧

**后端日志查看**:
```bash
# 查看应用日志
tail -f logs/application.log

# 查看错误日志
grep "ERROR" logs/application.log

# 查看特定用户的请求
grep "userId: 123" logs/application.log
```

**前端调试**:
```javascript
// 开启详细日志
localStorage.setItem('debug', 'true');

// 监控 API 请求
const originalFetch = window.fetch;
window.fetch = function(...args) {
  console.log('API 请求:', args);
  return originalFetch.apply(this, args).then(response => {
    console.log('API 响应:', response);
    return response;
  });
};
```

---

## 📚 总结

本文档详细介绍了 AI 零代码应用生成平台的后端实现，包括：

1. **架构设计**: 分层架构、包结构、设计模式
2. **核心功能**: AI 代码生成、工作流引擎、应用管理
3. **技术实现**: LangChain4j 集成、流式响应、缓存策略
4. **安全机制**: 身份认证、权限控制、限流保护
5. **前端集成**: API 调用、SSE 处理、错误处理

作为前端开发者，理解这些后端实现细节将帮助你：
- 更好地设计前端架构
- 优化 API 调用逻辑
- 处理各种异常情况
- 提升用户体验

如果你有任何问题或需要更详细的说明，请随时联系后端开发团队！
